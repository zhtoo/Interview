## 屏幕适配（探索）
### 一、TypedValue
用于动态类型化数据值的容器。 主要用于
{@link android.content.res.Resources}用于保存资源值。

TypedValue类在android.util包下，因此在需要计算dp、sp与px之间的关系的时候一般会被使用。（由此可见在View中最常见）

一个关键方法：

     public static float applyDimension(int unit, float value,
                                       DisplayMetrics metrics)
    {
        switch (unit) {
        case COMPLEX_UNIT_PX://px返回
            return value;
        case COMPLEX_UNIT_DIP://dip返回
            return value * metrics.density;
        case COMPLEX_UNIT_SP://sp返回
            return value * metrics.scaledDensity;
        case COMPLEX_UNIT_PT://点返回？？？
            return value * metrics.xdpi * (1.0f/72);
        case COMPLEX_UNIT_IN://英寸返回
            return value * metrics.xdpi;
        case COMPLEX_UNIT_MM://毫米返回
            return value * metrics.xdpi * (1.0f/25.4f);
        }
        return 0;
    }

通过上面的方法，可以发现dp、sp与px之间的关系。
PS：这里简单提一下，一般情况下 scaledDensity = density ，钻牛角尖或者真想弄清楚的同学，请自行阅读DisplayMetrics的源码。

metrics是啥？由方法传进来的。DisplayMetrics这个类先放一下。

TypedValue在 android.util 包下，说明是一个工具类。 那系统提供的View会不会都调用这个方法？

以TextView为例，来探索一下TypedValue：

TextView的构造方法的代码片段， displayMetrics的获取方法:getResources().getDisplayMetrics();

     final DisplayMetrics displayMetrics = getResources().getDisplayMetrics();

    if (autoSizeMinTextSizeInPx == UNSET_AUTO_SIZE_UNIFORM_CONFIGURATION_VALUE) {
        autoSizeMinTextSizeInPx = TypedValue.applyDimension(
                TypedValue.COMPLEX_UNIT_SP,
                DEFAULT_AUTO_SIZE_MIN_TEXT_SIZE_IN_SP,
                displayMetrics);
    }

setAutoSizeTextTypeWithDefaults（）中displayMetrics的获取方法:getResources().getDisplayMetrics();

    public void setAutoSizeTextTypeWithDefaults(@AutoSizeTextType int autoSizeTextType) {
        if (supportsAutoSizeText()) {
            switch (autoSizeTextType) {
               //...
              case AUTO_SIZE_TEXT_TYPE_UNIFORM:
                    final DisplayMetrics displayMetrics = getResources().getDisplayMetrics();
                    final float autoSizeMinTextSizeInPx = TypedValue.applyDimension(
                            TypedValue.COMPLEX_UNIT_SP,
                            DEFAULT_AUTO_SIZE_MIN_TEXT_SIZE_IN_SP,
                            displayMetrics);
                    final float autoSizeMaxTextSizeInPx = TypedValue.applyDimension(
                            TypedValue.COMPLEX_UNIT_SP,
                            DEFAULT_AUTO_SIZE_MAX_TEXT_SIZE_IN_SP,
                            displayMetrics);

                    //...
                    break;
               //...
            }
        }
    }

setAutoSizeTextTypeUniformWithConfiguration（）中displayMetrics的获取方法:getResources().getDisplayMetrics();

    public void setAutoSizeTextTypeUniformWithConfiguration(int autoSizeMinTextSize,
    int autoSizeMaxTextSize, int autoSizeStepGranularity, int unit) {
		if (supportsAutoSizeText()) {
			final DisplayMetrics displayMetrics = getResources().getDisplayMetrics();
			final float autoSizeMinTextSizeInPx = TypedValue.applyDimension(
			unit, autoSizeMinTextSize, displayMetrics);
			final float autoSizeMaxTextSizeInPx = TypedValue.applyDimension(
			unit, autoSizeMaxTextSize, displayMetrics);
			final float autoSizeStepGranularityInPx = TypedValue.applyDimension(
			unit, autoSizeStepGranularity, displayMetrics);
			
		//...
		}
    }

setAutoSizeTextTypeUniformWithPresetSizes中displayMetrics的获取方法:getResources().getDisplayMetrics();

	public void setAutoSizeTextTypeUniformWithPresetSizes(@NonNull int[] presetSizes, int unit) {
      //...
        final DisplayMetrics displayMetrics = getResources().getDisplayMetrics();
        // Convert all to sizes to pixels.
        for (int i = 0; i < presetSizesLength; i++) {
            presetSizesInPx[i] = Math.round(TypedValue.applyDimension(unit,
                presetSizes[i], displayMetrics));
        }
     //...
    }

setTextSizeInternal()中displayMetrics的获取方法:getResources().getDisplayMetrics();

ps:这里有个判断，重点看一下。

 	private void setTextSizeInternal(int unit, float size, boolean shouldRequestLayout) {
        Context c = getContext();
        Resources r;

        if (c == null) {
            r = Resources.getSystem();
        } else {
            r = c.getResources();
        }

        setRawTextSize(TypedValue.applyDimension(unit, size, r.getDisplayMetrics()),
                shouldRequestLayout);
    }

好了TetxView里面涉及TypedValue.applyDimension（）方法就是以上的的方法

##### 小结：

TypedValue.applyDimension（）方法中的DisplayMetrics是通过getResources().getDisplayMetrics()或者Resources.getSystem()获取的

### 二、getResources().getDisplayMetrics()中的getResources()的由来

getResources()来自View中的mResources成员变量,mResources的获取方法是在构造中获取的。代码如下：

     public View(Context context) {
        mContext = context;
        mResources = context != null ? context.getResources() : null;
        //...
    }

    View() {
        mResources = null;
       //...
    }

在我们自定义View的时候，必须要实现的方法都有Context的参数，Context从哪来？
在View中的Context通常是当前展示的Activity。

PS：context.getResources()是的Context里面的抽象方法 

### 三、Context是如何初始化Resources
这个类得单独拿出来说一下。

android.content包下面找到Context，ctrl + H 查看其继承关系:Context--->ContextWrapper--->ContextThemeWrapper--->Activity

（下面的代码只列出了与Context赋值和getResources()相关的代码，其他代码省略）

	ContextWrapper extends Context {
    	Context mBase;

	    public ContextWrapper(Context base) {
	        mBase = base;
	    } 
	
		@Override
	    public Resources getResources() {
	        return mBase.getResources();
	    }

		protected void attachBaseContext(Context base) {
	        if (mBase != null) {
	            throw new IllegalStateException("Base context already set");
	        }
	        mBase = base;
    	}
		
	}

	public class ContextThemeWrapper extends ContextWrapper {

		//因为设计到Context是 super()走的父类的方法，所以不copy出源码
	 	
		@Override
	    public Resources getResources() {
	        return getResourcesInternal();
	    }

		private Resources getResourcesInternal() {
	        if (mResources == null) {
	            if (mOverrideConfiguration == null) {
	                mResources = super.getResources();
	            } else {
	                final Context resContext = createConfigurationContext(mOverrideConfiguration);
	                mResources = resContext.getResources();
	            }
	        }
	        return mResources;
	    }
	
	}	

找不到具体实现的方法...然而Context却牵扯出很多东西，所以捋一捋思路。

第一步我们找到TypedValue，发现了dp、sp和px的关系都和DisplayMetrics类有关系，而DisplayMetrics又是通过getResources()来获取，所以我们的目标转向了getResources()
第二步我们发现View中的getResources()其实是来自宿主Activity的context
第三步查阅代码发现context并不具体实现getResources()方法，所以当前需要找到getResources()方法具体实现的地方。

PS:有人会有疑问 明明还有Resources.getSystem()为啥忽略。注意这里不是忽略，而是放下面讲。

### 四、Context的具体实现类ContextImpl

百度一下发现：Context 的具体实现类是ContextImpl。ContextImpl.java是保护文件，保存在SDk的安装目录中的sources文件夹中，相对路径：/android-sdk/sources/android-xx/android/app/ContextImpl.java。

好吧，能力有限，实在看不出来怎么实现的。那就看看代码：

找了半天具体赋值在这里：

	void setResources(Resources r) {
        if (r instanceof CompatResources) {
            ((CompatResources) r).setContext(this);
        }
        mResources = r;
    }

然后很无奈，又是作为参数传过来的，ctrl + F找到如下代码：

ContextImpl类的构造：

	  private ContextImpl(@Nullable ContextImpl container, //..) {
       //...
        if (container != null) {
            mBasePackageName = container.mBasePackageName;
            mOpPackageName = container.mOpPackageName;
            setResources(container.mResources);
            mDisplay = container.mDisplay;
        } else {
           //...
        }
    }

##### 下面是各种涉及setResources（）

createApplicationContext（）：

	@Override
    public Context createApplicationContext(ApplicationInfo application, int flags)
            throws NameNotFoundException {
        //...
        if (pi != null) {
            ContextImpl c = new ContextImpl(this, mMainThread, pi, null, mActivityToken,new UserHandle(UserHandle.getUserId(application.uid)), flags, null);

            final int displayId = mDisplay != null
                    ? mDisplay.getDisplayId() : Display.DEFAULT_DISPLAY;

            c.setResources(createResources(mActivityToken, pi, null, displayId, null,
                    getDisplayAdjustments(displayId).getCompatibilityInfo()));
            
			if (c.mResources != null) {
                return c;
            }
        }
    }

createPackageContextAsUser（）：

	@Override
    public Context createPackageContextAsUser(String packageName, int flags, UserHandle user)
            throws NameNotFoundException {
        //...
        if (pi != null) {
            ContextImpl c = new ContextImpl(this, mMainThread, pi, null, mActivityToken, user,flags, null);

            final int displayId = mDisplay != null
                    ? mDisplay.getDisplayId() : Display.DEFAULT_DISPLAY;

            c.setResources(createResources(mActivityToken, pi, null, displayId, null,
                    getDisplayAdjustments(displayId).getCompatibilityInfo()));
            if (c.mResources != null) {
                return c;
            }
        }
 		//...
    }

createContextForSplit（）：

	@Override
    public Context createContextForSplit(String splitName) throws NameNotFoundException {
        if (!mPackageInfo.getApplicationInfo().requestsIsolatedSplitLoading()) {
            // All Splits are always loaded.
            return this;
        }

        final ClassLoader classLoader = mPackageInfo.getSplitClassLoader(splitName);
        final String[] paths = mPackageInfo.getSplitPaths(splitName);

		//重点看这里，ContextImpl对象的初始化
        final ContextImpl context = new ContextImpl(this, mMainThread, mPackageInfo, splitName,mActivityToken, mUser, mFlags, classLoader);

        final int displayId = mDisplay != null
                ? mDisplay.getDisplayId() : Display.DEFAULT_DISPLAY;

		//这里设置Resources，注意在这里引入了一个新的方法
        context.setResources(ResourcesManager.getInstance().getResources(
                mActivityToken,
                mPackageInfo.getResDir(),
                paths,
                mPackageInfo.getOverlayDirs(),
                mPackageInfo.getApplicationInfo().sharedLibraryFiles,
                displayId,
                null,
                mPackageInfo.getCompatibilityInfo(),
                classLoader));
        return context;
    }

createConfigurationContext（）：

	@Override
    public Context createConfigurationContext(Configuration overrideConfiguration) {
        if (overrideConfiguration == null) {
            throw new IllegalArgumentException("overrideConfiguration must not be null");
        }

        ContextImpl context = new ContextImpl(this, mMainThread, mPackageInfo, mSplitName,mActivityToken, mUser, mFlags, mClassLoader);

        final int displayId = mDisplay != null ? mDisplay.getDisplayId() : Display.DEFAULT_DISPLAY;
        context.setResources(createResources(mActivityToken, mPackageInfo,
	 										mSplitName, displayId,
                							overrideConfiguration, 
											getDisplayAdjustments(displayId).getCompatibilityInfo()));
        return context;
    }

createDisplayContext():

	@Override
    public Context createDisplayContext(Display display) {
        if (display == null) {
            throw new IllegalArgumentException("display must not be null");
        }

        ContextImpl context = new ContextImpl(this, mMainThread, mPackageInfo, mSplitName,mActivityToken, mUser, mFlags, mClassLoader);

        final int displayId = display.getDisplayId();
        context.setResources(createResources(mActivityToken, mPackageInfo, mSplitName, displayId,null, getDisplayAdjustments(displayId).getCompatibilityInfo()));
        context.mDisplay = display;
        return context;
    }

createSystemContext():

	static ContextImpl createSystemContext(ActivityThread mainThread) {
        LoadedApk packageInfo = new LoadedApk(mainThread);
        ContextImpl context = new ContextImpl(null, mainThread, packageInfo, null, null, null, 0,null);
        context.setResources(packageInfo.getResources());
        context.mResources.updateConfiguration(context.mResourcesManager.getConfiguration(),
                context.mResourcesManager.getDisplayMetrics());
        return context;
    }

createSystemUiContext():

 	static ContextImpl createSystemUiContext(ContextImpl systemContext) {
        final LoadedApk packageInfo = systemContext.mPackageInfo;
        ContextImpl context = new ContextImpl(null, systemContext.mMainThread, packageInfo, null, null, null, 0,null);
        context.setResources(createResources(null, packageInfo, null, Display.DEFAULT_DISPLAY, null,
                packageInfo.getCompatibilityInfo()));
        return context;
    }

createAppContext():

	static ContextImpl createAppContext(ActivityThread mainThread, LoadedApk packageInfo) {
        if (packageInfo == null) throw new IllegalArgumentException("packageInfo");
        ContextImpl context = new ContextImpl(null, mainThread, packageInfo, null, null, null, 0,null);
        context.setResources(packageInfo.getResources());
        return context;
    }

createActivityContext():

	static ContextImpl createActivityContext(ActivityThread mainThread,
            LoadedApk packageInfo, ActivityInfo activityInfo, IBinder activityToken, int displayId,
            Configuration overrideConfiguration) {
       	//...
        ContextImpl context = new ContextImpl(null, mainThread, packageInfo, activityInfo.splitName,activityToken, null, 0, classLoader);

        displayId = (displayId != Display.INVALID_DISPLAY) ? displayId : Display.DEFAULT_DISPLAY;

        final CompatibilityInfo compatInfo = (displayId == Display.DEFAULT_DISPLAY)
                ? packageInfo.getCompatibilityInfo()
                : CompatibilityInfo.DEFAULT_COMPATIBILITY_INFO;

        final ResourcesManager resourcesManager = ResourcesManager.getInstance();

		//创建基础资源，此Activity的所有配置context都将重新定义。
        context.setResources(resourcesManager.createBaseActivityResources(activityToken,
                packageInfo.getResDir(),
                splitDirs,
                packageInfo.getOverlayDirs(),
                packageInfo.getApplicationInfo().sharedLibraryFiles,
                displayId,
                overrideConfiguration,
                compatInfo,
                classLoader));
        		context.mDisplay = resourcesManager.getAdjustedDisplay(displayId,
                context.getResources());
        return context;
    }

以上的方法基本上都是用来创建各种Context的。其中涉及Resources的创建方法createResources()，代码如下：

	private static Resources createResources(IBinder activityToken, LoadedApk pi, String splitName,
            int displayId, Configuration overrideConfig, CompatibilityInfo compatInfo) {
        final String[] splitResDirs;
        final ClassLoader classLoader;
        try {
            splitResDirs = pi.getSplitPaths(splitName);
            classLoader = pi.getSplitClassLoader(splitName);
        } catch (NameNotFoundException e) {
            throw new RuntimeException(e);
        }
        return ResourcesManager.getInstance().getResources(activityToken,
                pi.getResDir(),
                splitResDirs,
                pi.getOverlayDirs(),
                pi.getApplicationInfo().sharedLibraryFiles,
                displayId,
                overrideConfig,
                compatInfo,
                classLoader);
    }

#### 小结
ContextImpl类中的mResources的获取途径：

- packageInfo.getResources() （ LoadedApk packageInfo = new LoadedApk(mainThread);）
- ResourcesManager.getInstance().getResources()

ContextImpl创建是在 ActivityThread 创建时调用getSystemContext方法进行创建的（不同时期创建Context的方法的不同，详细创建方法参照上述的一堆getXXXContext）

    public ContextImpl getSystemContext() {
	    synchronized (this) {
		    if (mSystemContext == null) {
		    	mSystemContext = ContextImpl.createSystemContext(this);
		    }
		    return mSystemContext;
	    }
    }
 

### 五、ContextImpl的mResources的获取

#### LoadedApk

类注释：本地状态维持当前加载的apk。

    public final class LoadedApk {

		LoadedApk(ActivityThread activityThread) {
		    mActivityThread = activityThread;
		    mApplicationInfo = new ApplicationInfo();
		    mApplicationInfo.packageName = "android";
		    mPackageName = "android";
		    mAppDir = null;
		    mResDir = null;
		    mSplitAppDirs = null;
		    mSplitResDirs = null;
		    mSplitClassLoaderNames = null;
		    mOverlayDirs = null;
		    mDataDir = null;
		    mDataDirFile = null;
		    mDeviceProtectedDataDirFile = null;
		    mCredentialProtectedDataDirFile = null;
		    mLibDir = null;
		    mBaseClassLoader = null;
		    mSecurityViolation = false;
		    mIncludeCode = true;
		    mRegisterPackage = false;
		    mClassLoader = ClassLoader.getSystemClassLoader();
			//看着里，在这里赋值的Resources
		    mResources = Resources.getSystem();
		    mAppComponentFactory = createAppFactory(mApplicationInfo, mClassLoader);
		}
    
		/**
		* 获取Resources的方法。
		*/
		public Resources getResources() {
		    if (mResources == null) {
		        final String[] splitPaths;
		        try {
		            splitPaths = getSplitPaths(null);
		        } catch (NameNotFoundException e) {
		            // This should never fail.
		            throw new AssertionError("null split not found");
		        }
		
		        mResources = ResourcesManager.getInstance().getResources(null, mResDir,
		                splitPaths, mOverlayDirs, mApplicationInfo.sharedLibraryFiles,
		                Display.DEFAULT_DISPLAY, null, getCompatibilityInfo(),
		                getClassLoader());
		    }
		    return mResources;
		}
    }

新发现：Resources.getSystem() 和** ResourcesManager.getInstance().getResources（）**（熟悉吧）

#### ResourcesManager

先看代码：

	/** @hide */
	public class ResourcesManager {
	
		/**
		Gets or creates a new Resources object associated with the IBinder token. References returned by this method live as long as the Activity, meaning they can be cached and used by the Activity even after a configuration change. If any other parameter is change (resDir, splitResDirs, overrideConfig) for a given Activity, the same Resources object is updated and handed back to the caller. However, changing the class loader will result in a  new Resources object.
		获取或创建与IBinder令牌关联的新Resources对象。 此方法返回的引用与Activity一样，这意味着即使在配置更改后，Activity也可以缓存和使用它们。如果给定Activity的任何其他参数更改（resDir，splitResDirs，overrideConfig），则更新相同的Resources对象并将其传递回调用方。 但是，更改类加载器将导致新的Resources对象。
		 
		If activityToken is null, a cached Resources object will be returned if it matches the input parameters. Otherwise a new Resources object that satisfies these parameters is returned.
		如果activityToken为null，则如果匹配输入参数，则将返回缓存的Resources对象。否则，将返回满足这些参数的新Resources对象。
		感觉google翻译有点机器。下面是夏笔笔翻译的：
		在activityToken为null的前提下，如果能够匹配输入参数那么就返回缓存的Resources对象。否则，将返回满足这些参数的新Resources对象。

		* @param activityToken Represents an Activity. If null, global resources are assumed.
							   表示一个Activity。 如果为null，则假定为全局资源。
		* @param resDir The base resource path. Can be null (only framework resources will be loaded).
						基本资源路径。 可以为null（仅加载框架资源）。
		* @param splitResDirs An array of split resource paths. Can be null.
							  分割资源路径的数组。 可以为null。
		* @param overlayDirs An array of overlay paths. Can be null.
		* 一系列叠加路径。 可以为null。
		* @param libDirs An array of resource library paths. Can be null.
		* 一组资源库路径。 可以为null。
		* @param displayId The ID of the display for which to create the resources.
		* 要为其创建资源的显示的ID。
		* @param overrideConfig The configuration to apply on top of the base configuration. Can be
		* null. Mostly used with Activities that are in multi-window which may override width and
		* height properties from the base config.
		* 要在基本配置之上应用的配置。 可以为null。 主要用于多窗口中的活动，可以覆盖基本配置中的宽度和高度属性。
		* @param compatInfo The compatibility settings to use. Cannot be null. A default to use is
		* {@link CompatibilityInfo#DEFAULT_COMPATIBILITY_INFO}.
		* 要使用的兼容性设置。 不能为空。 默认使用的是{@link CompatibilityInfo＃DEFAULT_COMPATIBILITY_INFO}。
		* @param classLoader The class loader to use when inflating Resources. If null, the
		* {@link ClassLoader#getSystemClassLoader()} is used.
		* 在inflat资源时使用的类加载器。 如果为null，则使用{@link ClassLoader＃getSystemClassLoader（）}。
		* @return a Resources object from which to access resources.
		*/
		public @Nullable Resources getResources(@Nullable IBinder activityToken,
		        @Nullable String resDir,
		        @Nullable String[] splitResDirs,
		        @Nullable String[] overlayDirs,
		        @Nullable String[] libDirs,
		        int displayId,
		        @Nullable Configuration overrideConfig,
		        @NonNull CompatibilityInfo compatInfo,
		        @Nullable ClassLoader classLoader) {
		    try {
		        Trace.traceBegin(Trace.TRACE_TAG_RESOURCES, "ResourcesManager#getResources");
		        final ResourcesKey key = new ResourcesKey(
		                resDir,
		                splitResDirs,
		                overlayDirs,
		                libDirs,
		                displayId,
		                overrideConfig != null ? new Configuration(overrideConfig) : null, // Copy
		                compatInfo);
		        classLoader = classLoader != null ? classLoader : ClassLoader.getSystemClassLoader();
		        return getOrCreateResources(activityToken, key, classLoader);
		    } finally {
		        Trace.traceEnd(Trace.TRACE_TAG_RESOURCES);
		    }
		}

	}


    /**
     * Gets an existing Resources object set with a ResourcesImpl object matching the given key,
     * or creates one if it doesn't exist.
     *
     * @param activityToken The Activity this Resources object should be associated with.
     * @param key The key describing the parameters of the ResourcesImpl object.
     * @param classLoader The classloader to use for the Resources object.
     *                    If null, {@link ClassLoader#getSystemClassLoader()} is used.
     * @return A Resources object that gets updated when
     *         {@link #applyConfigurationToResourcesLocked(Configuration, CompatibilityInfo)}
     *         is called.
     */
    private @Nullable Resources getOrCreateResources(@Nullable IBinder activityToken,
            @NonNull ResourcesKey key, @NonNull ClassLoader classLoader) {
        synchronized (this) {
            //...
            if (activityToken != null) {
                final ActivityResources activityResources =
                        getOrCreateActivityResourcesStructLocked(activityToken);

                ArrayUtils.unstableRemoveIf(activityResources.activityResources,
                        sEmptyReferencePredicate);

                if (key.hasOverrideConfiguration()
                        && !activityResources.overrideConfig.equals(Configuration.EMPTY)) {

                    final Configuration temp = new Configuration(activityResources.overrideConfig);
                    temp.updateFrom(key.mOverrideConfiguration);
                    key.mOverrideConfiguration.setTo(temp);
                }

                ResourcesImpl resourcesImpl = findResourcesImplForKeyLocked(key);
                if (resourcesImpl != null) {
                    if (DEBUG) {
                        Slog.d(TAG, "- using existing impl=" + resourcesImpl);
                    }
                    return getOrCreateResourcesForActivityLocked(activityToken, classLoader,
                            resourcesImpl, key.mCompatInfo);
                }

            } else {
                ArrayUtils.unstableRemoveIf(mResourceReferences, sEmptyReferencePredicate);
                ResourcesImpl resourcesImpl = findResourcesImplForKeyLocked(key);
                if (resourcesImpl != null) {
                    return getOrCreateResourcesLocked(classLoader, resourcesImpl, key.mCompatInfo);
                }
            }

            ResourcesImpl resourcesImpl = createResourcesImpl(key);
            if (resourcesImpl == null) {
                return null;

            mResourceImpls.put(key, new WeakReference<>(resourcesImpl));

            final Resources resources;
            if (activityToken != null) {
                resources = getOrCreateResourcesForActivityLocked(activityToken, classLoader,
                        resourcesImpl, key.mCompatInfo);
            } else {
                resources = getOrCreateResourcesLocked(classLoader, resourcesImpl, key.mCompatInfo);
            }
            return resources;
        }
    }

     /**
     * Gets an existing Resources object tied to this Activity, or creates one if it doesn't exist
     * or the class loader is different.
     */
    private @NonNull Resources getOrCreateResourcesForActivityLocked(@NonNull IBinder activityToken,
            @NonNull ClassLoader classLoader, @NonNull ResourcesImpl impl,
            @NonNull CompatibilityInfo compatInfo) {
        final ActivityResources activityResources = getOrCreateActivityResourcesStructLocked(
                activityToken);

        final int refCount = activityResources.activityResources.size();

        for (int i = 0; i < refCount; i++) {
            WeakReference<Resources> weakResourceRef = activityResources.activityResources.get(i);
            Resources resources = weakResourceRef.get();

            if (resources != null
                    && Objects.equals(resources.getClassLoader(), classLoader)
                    && resources.getImpl() == impl) {
                if (DEBUG) {
                    Slog.d(TAG, "- using existing ref=" + resources);
                }
                return resources;
            }
        }

        Resources resources = compatInfo.needsCompatResources() ? new CompatResources(classLoader)
                : new Resources(classLoader);
        resources.setImpl(impl);
        activityResources.activityResources.add(new WeakReference<>(resources));

        return resources;
    }

    /**
     * Gets an existing Resources object if the class loader and ResourcesImpl are the same,
     * otherwise creates a new Resources object.
     */
    private @NonNull Resources getOrCreateResourcesLocked(@NonNull ClassLoader classLoader,
            @NonNull ResourcesImpl impl, @NonNull CompatibilityInfo compatInfo) {
         
        final int refCount = mResourceReferences.size();
        for (int i = 0; i < refCount; i++) {
            WeakReference<Resources> weakResourceRef = mResourceReferences.get(i);
            Resources resources = weakResourceRef.get();
            if (resources != null &&
                    Objects.equals(resources.getClassLoader(), classLoader) &&
                    resources.getImpl() == impl) {
                if (DEBUG) {
                    Slog.d(TAG, "- using existing ref=" + resources);
                }
                return resources;
            }
        }

        Resources resources = compatInfo.needsCompatResources() ? new CompatResources(classLoader)
                : new Resources(classLoader);
        resources.setImpl(impl);
        mResourceReferences.add(new WeakReference<>(resources));
        return resources;
    }


#### Resources 

    public class Resources {

		/**
         * Returns the resources to which this theme belongs.
         *	返回此主题所属的资源。
         * @return Resources to which this theme belongs.
         */
        public Resources getResources() {
            return Resources.this;
        }

		/**
		 * Return a global shared Resources object that provides access to only
		 * system resources (no application resources), and is not configured for
		 * the current screen (can not use dimension units, does not change based
		 * on orientation, etc).
		 * 返回一个全局共享资源对象，该对象仅提供对系统资源的访问权限（无应用程序资源），并且未针对当前屏幕进行配置（不能使用维度单位，不会根据方向更改等）。
		 */
		public static Resources getSystem() {
		    synchronized (sSync) {
		        Resources ret = mSystem;
		        if (ret == null) {
		            ret = new Resources();
		            mSystem = ret;
		        }
		        return ret;
		    }
		}

		/**
		* Only for creating the System resources.
		* 仅用于创建系统资源。
		*/
		private Resources() {
			this(null);
			
			final DisplayMetrics metrics = new DisplayMetrics();
			metrics.setToDefaults();
			
			final Configuration config = new Configuration();
			config.setToDefaults();
			
			mResourcesImpl = new ResourcesImpl(AssetManager.getSystem(), metrics, config,new DisplayAdjustments());
		}

		
		/**
		 * Create a new Resources object on top of an existing set of assets in an
		 * AssetManager.
		 * 在AssetManager中的现有资产集之上创建新的Resources对象。
		 *
		 * @deprecated Resources should not be constructed by apps.
		 * See {@link android.content.Context#createConfigurationContext(Configuration)}.
		 *	弃用：资源不应该由app构建。参见{@link android.content.Context #createConfigurationContext（Configuration）}。
		 * @param assets Previously created AssetManager.
		 * @param metrics Current display metrics to consider when
		 *                selecting/computing resource values.
		 * @param config Desired device configuration to consider when
		 *               selecting/computing resource values (optional).
		 */
		@Deprecated
		public Resources(AssetManager assets, DisplayMetrics metrics, Configuration config) {
		    this(null);
		    mResourcesImpl = new ResourcesImpl(assets, metrics, config, new DisplayAdjustments());
		}
		
		/**
		* Creates a new Resources object with CompatibilityInfo.
		* 使用CompatibilityInfo创建一个新的Resources对象。
		*
		* @param classLoader class loader for the package used to load custom
		*                    resource classes, may be {@code null} to use system
		*                    class loader
		*                    用于加载自定义资源类的包的类加载器，可以是{@code null}来使用系统类加载器
		* @hide
		*/
		public Resources(@Nullable ClassLoader classLoader) {
			mClassLoader = classLoader == null ? ClassLoader.getSystemClassLoader() : classLoader;
		}
		
		
    }


上面主要由用的方法是：getSystem() 和 getResources() 

### 六、ContextImpl和Activity的关系

都说ContextImpl是Context的具体实现类，而Activity又是Context的子类，那么ContextImpl到底实在何时实例化的？这个就要看看Activity的代码了，因为Activity的父类Context--->ContextWrapper--->ContextThemeWrapper都不没有ContextImpl的实例。

#### 如何分析Activity？
最简单的就是从startActivity入手

下面的分析以方法为步骤来 夏笔笔

> **Activity.startActivity()**

	/*
	 我们一般启动Activity会调用
	 */
	@Override
	public void startActivity(Intent intent) {
	    this.startActivity(intent, null);
	}

    @Override
    public void startActivity(Intent intent, @Nullable Bundle options) {
        if (options != null) {
			//Bundle非空会调这个方法
            startActivityForResult(intent, -1, options);
        } else {
           	//我们一般走的是这个
			startActivityForResult(intent, -1);
        }
    }

    public void startActivityForResult(@RequiresPermission Intent intent, int requestCode) {
        startActivityForResult(intent, requestCode, null);
    }

	//这里是调用startActivity后在Activity中最终走的方法
	public void startActivityForResult(@RequiresPermission Intent intent, int requestCode,@Nullable Bundle options) {
		//判断mParent是否为空： Activity mParent;
		//感觉要来分析一波了，mInstrumentation的注释是：在构造函数之后和调用onCreate（Bundle savedInstanceState）之前由线程设置。
		//引出了一个新类Instrumentation和方法execStartActivity
		if (mParent == null) {

		    options = transferSpringboardActivityOptions(options);
		    Instrumentation.ActivityResult ar =
		        mInstrumentation.execStartActivity(
		            this, mMainThread.getApplicationThread(), mToken, this,
		            intent, requestCode, options);
		    if (ar != null) {
		        mMainThread.sendActivityResult(
		            mToken, mEmbeddedID, requestCode, ar.getResultCode(),
		            ar.getResultData());
		    }
		    if (requestCode >= 0) {
		        mStartedActivity = true;
		    }
		    cancelInputsAndStartExitTransition(options);
		    
		} else {
			//这里执行的代码和上面的分析的一样，都会调用execStartActivity（）方法
		    if (options != null) {
		        mParent.startActivityFromChild(this, intent, requestCode, options);
		    } else {
		        mParent.startActivityFromChild(this, intent, requestCode);
		    }
		}
	}

	//佐证上面的说法，感觉还是贴出代码要严谨点。	
	 public void startActivityFromChild(@NonNull Activity child, @RequiresPermission Intent intent,int requestCode, @Nullable Bundle options) {
        options = transferSpringboardActivityOptions(options);
        Instrumentation.ActivityResult ar =
            mInstrumentation.execStartActivity(
                this, mMainThread.getApplicationThread(), mToken, child,
                intent, requestCode, options);
        if (ar != null) {
            mMainThread.sendActivityResult(
                mToken, child.mEmbeddedID, requestCode,
                ar.getResultCode(), ar.getResultData());
        }
        cancelInputsAndStartExitTransition(options);
    }

> **Instrumentation.execStartActivity**

	//执行应用程序发出的startActivity调用。 
	//默认实现负责更新任何活动的{@link ActivityMonitor}对象，
	//并将此调用分派给系统活动管理器; 
	//你可以覆盖它来监视应用程序启动一个活动，并修改它发生时会发生什么。

	//此方法返回一个{@link ActivityResult}对象，
	//您可以在拦截应用程序调用时使用该对象，
	//以避免执行启动活动操作但仍返回应用程序所期望的结果。 
	//为此，重写此方法以捕获对start活动的调用，以便它返回一个新的ActivityResult，
	//其中包含您希望应用程序看到的结果，并且不会调用超类。 
	//请注意，如果requestCode>= 0，则应用程序仅期望结果。

	public ActivityResult execStartActivity(
            Context who, IBinder contextThread, IBinder token, Activity target,
            Intent intent, int requestCode, Bundle options) {

		//将IBinder类强转为IApplicationThread
        IApplicationThread whoThread = (IApplicationThread) contextThread;
		
        Uri referrer = target != null ? target.onProvideReferrer() : null;
        if (referrer != null) {
            intent.putExtra(Intent.EXTRA_REFERRER, referrer);
        }

		
		//查看代码可以发现ActivityMonitor是Instrumentation的内部类，
		//mActivityMonitors是一个List<ActivityMonitor>,
		//仔细看一下ActivityMonitor代码可以发现ActivityMonitor并不涉及ActivityResult具体实例化
        if (mActivityMonitors != null) {
            synchronized (mSync) {
                final int N = mActivityMonitors.size();
                for (int i=0; i<N; i++) {
                    final ActivityMonitor am = mActivityMonitors.get(i);
                    ActivityResult result = null;
                    if (am.ignoreMatchingSpecificIntents()) {
                        result = am.onStartActivity(intent);
                    }
                    if (result != null) {
                        am.mHits++;
                        return result;
                    } else if (am.match(who, null, intent)) {
                        am.mHits++;
                        if (am.isBlocking()) {
                            return requestCode >= 0 ? am.getResult() : null;
                        }
                        break;
                    }
                }
            }
        }
		//所以关键代码是下面的部分
		//ActivityResult：活动执行结果的描述，以返回到原始活动。
        try {
            intent.migrateExtraStreamToClipData();
            intent.prepareToLeaveProcess(who);
			//这里又调用了新的方法
			// ActivityManager.getService().startActivity
            int result = ActivityManager.getService()
                .startActivity(whoThread, who.getBasePackageName(), intent,
                        intent.resolveTypeIfNeeded(who.getContentResolver()),
                        token, target != null ? target.mEmbeddedID : null,
                        requestCode, 0, null, options);
            checkStartActivityResult(result, intent);
        } catch (RemoteException e) {
            throw new RuntimeException("Failure from system", e);
        }
        return null;
    }

	//类似于{@link #execStartActivity（android.content.Context，android.os.IBinder，android.os.IBinder，String，android.content.Intent，int，android.os.Bundle）}，但来调用是来自Fragment。
	 public ActivityResult execStartActivity(
        Context who, IBinder contextThread, IBinder token, String target,
        Intent intent, int requestCode, Bundle options) {
        IApplicationThread whoThread = (IApplicationThread) contextThread;
        if (mActivityMonitors != null) {
            synchronized (mSync) {
                final int N = mActivityMonitors.size();
                for (int i=0; i<N; i++) {
                    final ActivityMonitor am = mActivityMonitors.get(i);
                    ActivityResult result = null;
                    if (am.ignoreMatchingSpecificIntents()) {
                        result = am.onStartActivity(intent);
                    }
                    if (result != null) {
                        am.mHits++;
                        return result;
                    } else if (am.match(who, null, intent)) {
                        am.mHits++;
                        if (am.isBlocking()) {
                            return requestCode >= 0 ? am.getResult() : null;
                        }
                        break;
                    }
                }
            }
        }
        try {
            intent.migrateExtraStreamToClipData();
            intent.prepareToLeaveProcess(who);
            int result = ActivityManager.getService()
                .startActivity(whoThread, who.getBasePackageName(), intent,
                        intent.resolveTypeIfNeeded(who.getContentResolver()),
                        token, target, requestCode, 0, null, options);
            checkStartActivityResult(result, intent);
        } catch (RemoteException e) {
            throw new RuntimeException("Failure from system", e);
        }
        return null;
    }


	//类似于{@link #execStartActivity（Context，IBinder，IBinder，Activity，Intent，int，Bundle）}，但是为特定用户启动。
	 public ActivityResult execStartActivity(
            Context who, IBinder contextThread, IBinder token, String resultWho,
            Intent intent, int requestCode, Bundle options, UserHandle user) {
        IApplicationThread whoThread = (IApplicationThread) contextThread;
        if (mActivityMonitors != null) {
            synchronized (mSync) {
                final int N = mActivityMonitors.size();
                for (int i=0; i<N; i++) {
                    final ActivityMonitor am = mActivityMonitors.get(i);
                    ActivityResult result = null;
                    if (am.ignoreMatchingSpecificIntents()) {
                        result = am.onStartActivity(intent);
                    }
                    if (result != null) {
                        am.mHits++;
                        return result;
                    } else if (am.match(who, null, intent)) {
                        am.mHits++;
                        if (am.isBlocking()) {
                            return requestCode >= 0 ? am.getResult() : null;
                        }
                        break;
                    }
                }
            }
        }
        try {
            intent.migrateExtraStreamToClipData();
            intent.prepareToLeaveProcess(who);
            int result = ActivityManager.getService()
                .startActivityAsUser(whoThread, who.getBasePackageName(), intent,
                        intent.resolveTypeIfNeeded(who.getContentResolver()),
                        token, resultWho,
                        requestCode, 0, null, options, user.getIdentifier());
            checkStartActivityResult(result, intent);
        } catch (RemoteException e) {
            throw new RuntimeException("Failure from system", e);
        }
        return null;
    }


> **ActivityManager.getService().startActivity（）**

1、ActivityManager中只有AppTask有startActivity()方法。所以先看getService()

    public static IActivityManager getService() {
        return IActivityManagerSingleton.get();
    }

2、IActivityManagerSingleton是个单例：

	 private static final Singleton<IActivityManager> IActivityManagerSingleton =
	            new Singleton<IActivityManager>() {
	                @Override
	                protected IActivityManager create() {
	                    final IBinder b = ServiceManager.getService(Context.ACTIVITY_SERVICE);
	                    final IActivityManager am = IActivityManager.Stub.asInterface(b);
	                    return am;
	                }
	            };


3、ServiceManager.getService（）：返回对具有给定名称的Service的引用。

	public static IBinder getService(String name) {
		try {
		    IBinder service = sCache.get(name);
		    if (service != null) {
		        return service;
		    } else {
		        return Binder.allowBlocking(getIServiceManager().getService(name));
		    }
		} catch (RemoteException e) {
		    Log.e(TAG, "error in getService", e);
		}
		return null;
	}

PS：这里涉及Binder，就不分析下去了，Binder请自行找资料学习。

ServiceManager.getService(Context.ACTIVITY_SERVICE)这应该是去获取一个Service的引用
去Context看：

	/**
     与{@link #getSystemService（String）}一起使用以检索{@link android.app.ActivityManager}以与全局系统状态进行交互。
     * @see #getSystemService(String)
     * @see android.app.ActivityManager
     */
    public static final String ACTIVITY_SERVICE = "activity";

线索在这里就断了，然鹅度娘会说 ActivityManagerService是ActivityManager的具体实现类

猜想：ServiceManager.getService(Context.ACTIVITY_SERVICE)返回的会不会是ActivityManagerService？

4、ActivityManagerService 

	public class ActivityManagerService extends IActivityManager.Stub
	        implements Watchdog.Monitor, BatteryStatsImpl.BatteryCallback {

		@Override
	    public final int startActivity(IApplicationThread caller, String callingPackage,
	            Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode,
	            int startFlags, ProfilerInfo profilerInfo, Bundle bOptions) {

	        return startActivityAsUser(caller, callingPackage, intent, resolvedType, resultTo,
	                resultWho, requestCode, startFlags, profilerInfo, bOptions,
	                UserHandle.getCallingUserId());
	    }

		
	}

> **ActivityManagerService.startActivityAsUser()**

    @Override
    public final int startActivityAsUser(IApplicationThread caller, String callingPackage,
            Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode,
            int startFlags, ProfilerInfo profilerInfo, Bundle bOptions, int userId) {
        return startActivityAsUser(caller, callingPackage, intent, resolvedType, resultTo,
                resultWho, requestCode, startFlags, profilerInfo, bOptions, userId,
                true /*validateIncomingUser*/);
    }

	//API28
    public final int startActivityAsUser(IApplicationThread caller, String callingPackage,
            Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode,
            int startFlags, ProfilerInfo profilerInfo, Bundle bOptions, int userId,
            boolean validateIncomingUser) {

        enforceNotIsolatedCaller("startActivity");

        userId = mActivityStartController.checkTargetUser(userId, validateIncomingUser,
                Binder.getCallingPid(), Binder.getCallingUid(), "startActivityAsUser");

        // TODO: Switch to user app stacks here.
        return mActivityStartController.obtainStarter(intent, "startActivityAsUser")
                .setCaller(caller)
                .setCallingPackage(callingPackage)
                .setResolvedType(resolvedType)
                .setResultTo(resultTo)
                .setResultWho(resultWho)
                .setRequestCode(requestCode)
                .setStartFlags(startFlags)
                .setProfilerInfo(profilerInfo)
                .setActivityOptions(bOptions)
                .setMayWait(userId)
                .execute();

    }


	//API27
	@Override
    public final int startActivityAsUser(IApplicationThread caller, String callingPackage,
            Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode,
            int startFlags, ProfilerInfo profilerInfo, Bundle bOptions, int userId) {

        enforceNotIsolatedCaller("startActivity");
        userId = mUserController.handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(),userId, false, ALLOW_FULL_ONLY, "startActivity", null);

        // TODO: Switch to user app stacks here.
        return mActivityStarter.startActivityMayWait(caller, -1, callingPackage, intent,
                resolvedType, null, null, resultTo, resultWho, requestCode, startFlags,
                profilerInfo, null, null, bOptions, false, userId, null, "startActivityAsUser");
    }

在这里Api28和API27的调用方式不一样

API27分析：ActivityStarter类

    final int startActivityMayWait(IApplicationThread caller, int callingUid,
            String callingPackage, Intent intent, String resolvedType,
            IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,
            IBinder resultTo, String resultWho, int requestCode, int startFlags,
            ProfilerInfo profilerInfo, WaitResult outResult,
            Configuration globalConfig, Bundle bOptions, boolean ignoreTargetSecurity, int userId,
            TaskRecord inTask, String reason) {

       		//...
            int res = startActivityLocked(caller, intent, ephemeralIntent, resolvedType,
                    aInfo, rInfo, voiceSession, voiceInteractor,
                    resultTo, resultWho, requestCode, callingPid,
                    callingUid, callingPackage, realCallingPid, realCallingUid, startFlags,
                    options, ignoreTargetSecurity, componentSpecified, outRecord, inTask,
                    reason);
			//...
            return res;
        }
    }

返回的是res，然而 res = startActivityLocked(...)

    int startActivityLocked(IApplicationThread caller, Intent intent, Intent ephemeralIntent,
            String resolvedType, ActivityInfo aInfo, ResolveInfo rInfo,
            IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,
            IBinder resultTo, String resultWho, int requestCode, int callingPid, int callingUid,
            String callingPackage, int realCallingPid, int realCallingUid, int startFlags,
            ActivityOptions options, boolean ignoreTargetSecurity, boolean componentSpecified,
            ActivityRecord[] outActivity, TaskRecord inTask, String reason) {
		//...
        mLastStartActivityResult = startActivity(caller, intent, ephemeralIntent,resolvedType,
                aInfo, rInfo, voiceSession, voiceInteractor, resultTo, resultWho, requestCode,
                callingPid, callingUid, callingPackage, realCallingPid, realCallingUid, startFlags,
                options, ignoreTargetSecurity, componentSpecified, mLastStartActivityRecord,
                inTask);
		//...
        return mLastStartActivityResult != START_ABORTED ? mLastStartActivityResult : START_SUCCESS;
    }

返回值：mLastStartActivityResult = startActivity（）

    /** DO NOT call this method directly. Use {@link #startActivityLocked} instead. */
    private int startActivity(IApplicationThread caller, Intent intent, Intent ephemeralIntent,
            String resolvedType, ActivityInfo aInfo, ResolveInfo rInfo,
            IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,
            IBinder resultTo, String resultWho, int requestCode, int callingPid, int callingUid,
            String callingPackage, int realCallingPid, int realCallingUid, int startFlags,
            ActivityOptions options, boolean ignoreTargetSecurity, boolean componentSpecified,
            ActivityRecord[] outActivity, TaskRecord inTask) {
		//...
        return startActivity(r, sourceRecord, voiceSession, voiceInteractor, startFlags, true,
                options, inTask, outActivity);
    }

	 private int startActivity(final ActivityRecord r, ActivityRecord sourceRecord,
	            IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,
	            int startFlags, boolean doResume, ActivityOptions options, TaskRecord inTask,
	            ActivityRecord[] outActivity) {

	        int result = START_CANCELED;
	        try {
	           	//...
	            result = startActivityUnchecked(r, sourceRecord, voiceSession, voiceInteractor,
	                    startFlags, doResume, options, inTask, outActivity);
	        } finally {
	          //...
	        }
			//...
	        return result;
	    }

返回值：result = startActivityUnchecked（）。这个分析起来有点头痛，既然是有返回，我们可以从返回值下手。

    // Note: This method should only be called from {@link startActivity}.
    private int startActivityUnchecked(
			final ActivityRecord r, 
			ActivityRecord sourceRecord,
			IVoiceInteractionSession voiceSession,
			IVoiceInteractor voiceInteractor,
			int startFlags, 
			boolean doResume, 
			ActivityOptions options, 
			TaskRecord inTask,
            ActivityRecord[] outActivity) {

		//设置初始状态
        setInitialState(r, options, inTask, doResume, startFlags, sourceRecord,voiceSession,voiceInteractor);
		//计算启动任务标志
        computeLaunchingTaskFlags();
		//计算源堆栈
        computeSourceStack();

        mIntent.setFlags(mLaunchFlags);
 
		//方法名的意思是：获得可复用的意图Activity，
		//方法注释是：确定是否应将新Activity插入现有任务。 如果不是，则返回null;如果要添加新Activity的任务，则返回ActivityRecord。
		//如果是开启一个新的Activity，那么这里返回null，不信的去看getReusableIntentActivity（）的源码
        ActivityRecord reusedActivity = getReusableIntentActivity();

        final int preferredLaunchStackId =
                (mOptions != null) ? mOptions.getLaunchStackId() : INVALID_STACK_ID;
        final int preferredLaunchDisplayId =
                (mOptions != null) ? mOptions.getLaunchDisplayId() : DEFAULT_DISPLAY;
		//这一步代码，可以忽略
        if (reusedActivity != null) {
            //设置标志NEW_TASK和CLEAR_TASK后，任务将被重用，但仍需要锁定任务模式，因为任务被清除，否则设备将离开锁定的任务。
            if (mSupervisor.isLockTaskModeViolation(reusedActivity.getTask(),
                    (mLaunchFlags & (FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_CLEAR_TASK))
                            == (FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_CLEAR_TASK))) {
                mSupervisor.showLockTaskToast();
                Slog.e(TAG, "startActivityUnchecked: Attempt to violate Lock Task Mode");

				//开始返回锁定任务模式违规，这里是错误提示
                return START_RETURN_LOCK_TASK_MODE_VIOLATION;

            }

            if (mStartActivity.getTask() == null) {
                mStartActivity.setTask(reusedActivity.getTask());
            }
            if (reusedActivity.getTask().intent == null) {
                //这个任务是因为基于亲和力的Activity的移除而开始的...现在我们实际上正在启动它，我们可以分配基本意图。
                reusedActivity.getTask().setIntent(mStartActivity);
            }

            
            if ((mLaunchFlags & FLAG_ACTIVITY_CLEAR_TOP) != 0
                    || isDocumentLaunchesIntoExisting(mLaunchFlags)
                    || mLaunchSingleInstance || mLaunchSingleTask) {
                final TaskRecord task = reusedActivity.getTask();
				//执行清除任务以重新锁定
                final ActivityRecord top = task.performClearTaskForReuseLocked(mStartActivity,
                        mLaunchFlags);
                if (reusedActivity.getTask() == null) {
                    reusedActivity.setTask(task);
                }

                if (top != null) {
                    if (top.frontOfTask) {
                        top.getTask().setIntent(mStartActivity);
                    }
                    deliverNewIntent(top);
                }
            }

			//如果需要，发送启动启动的电源提示
            sendPowerHintForLaunchStartIfNeeded(false /* forceSend */, reusedActivity);

			//如果需要，设置目标堆栈并移动到前面
            reusedActivity = setTargetStackAndMoveToFrontIfNeeded(reusedActivity);

            final ActivityRecord outResult =
                    outActivity != null && outActivity.length > 0 ? outActivity[0] : null;

            if (outResult != null && (outResult.finishing || outResult.noDisplay)) {
                outActivity[0] = reusedActivity;
            }

            if ((mStartFlags & START_FLAG_ONLY_IF_NEEDED) != 0) {
                resumeTargetStackIfNeeded();
				//开始返回给调用者的意图。我们只是startActivity，不会有回调，所以不在这里
                return START_RETURN_INTENT_TO_CALLER;
            }
            setTaskFromIntentActivity(reusedActivity);

            if (!mAddingToTask && mReuseTask == null) {
                resumeTargetStackIfNeeded();
                if (outActivity != null && outActivity.length > 0) {
                    outActivity[0] = reusedActivity;
                }
				//开始前面任务
                return START_TASK_TO_FRONT;
            }
        }

		//packageName为空。
        if (mStartActivity.packageName == null) {
            final ActivityStack sourceStack = mStartActivity.resultTo != null
                    ? mStartActivity.resultTo.getStack() : null;
            if (sourceStack != null) {
                sourceStack.sendActivityResultLocked(-1 /* callingUid */, mStartActivity.resultTo,
                        mStartActivity.resultWho, mStartActivity.requestCode, RESULT_CANCELED,
                        null /* data */);
            }
            ActivityOptions.abort(mOptions);
			//开启类没有找到 
            return START_CLASS_NOT_FOUND;
        }

        //如果正在启动的Activity与当前在顶部的Activity相同，那么我们需要检查它是否应该只启动一次。
		//这一步是判断启动的Activity与当前在顶部的Activity是否相同，相同则走下面代码
        final ActivityStack topStack = mSupervisor.mFocusedStack;
        final ActivityRecord topFocused = topStack.topActivity();
        final ActivityRecord top = topStack.topRunningNonDelayedActivityLocked(mNotTop);
        final boolean dontStart = top != null && mStartActivity.resultTo == null
                && top.realActivity.equals(mStartActivity.realActivity)
                && top.userId == mStartActivity.userId
                && top.app != null && top.app.thread != null
                && ((mLaunchFlags & FLAG_ACTIVITY_SINGLE_TOP) != 0
                || mLaunchSingleTop || mLaunchSingleTask);
		//如果是开启一个新的Activity，那么启动的Activity与在栈顶Activity是不相同，dontStart = false
        if (dontStart) {
            topStack.mLastPausedActivity = null;
            if (mDoResume) {
                mSupervisor.resumeFocusedStackTopActivityLocked();
            }
            ActivityOptions.abort(mOptions);
            if ((mStartFlags & START_FLAG_ONLY_IF_NEEDED) != 0) {
                //我们不需要开始新的Activity，如果是这样的话，客户说没有做任何事情，所以就是这样！
                return START_RETURN_INTENT_TO_CALLER;
            }

            deliverNewIntent(top);

            //不要使用mStartActivity.task来显示Toast。 我们没有开始新的Activity，而是重复使用'顶级'。 mStartActivity中的字段可能未完全初始化。
            mSupervisor.handleNonResizableTaskIfNeeded(top.getTask(), preferredLaunchStackId,
                    preferredLaunchDisplayId, topStack.mStackId);
			//开始交付到顶部
            return START_DELIVERED_TO_TOP;
        }
		
        boolean newTask = false;
        final TaskRecord taskToAffiliate = (mLaunchTaskBehind && mSourceRecord != null)
                ? mSourceRecord.getTask() : null;

        // Should this be considered a new task?
        int result = START_SUCCESS;

		 
        if (mStartActivity.resultTo == null && mInTask == null && !mAddingToTask
                && (mLaunchFlags & FLAG_ACTIVITY_NEW_TASK) != 0) {
            newTask = true;
            result = setTaskFromReuseOrCreateNewTask(
                    taskToAffiliate, preferredLaunchStackId, topStack);
        } else if (mSourceRecord != null) {
            result = setTaskFromSourceRecord();
        } else if (mInTask != null) {
            result = setTaskFromInTask();
        } else {
            // This not being started from an existing activity, and not part of a new task...
            // just put it in the top task, though these days this case should never happen.
            setTaskToCurrentTopOrCreateNewTask();
        }
        if (result != START_SUCCESS) {
            return result;
        }

        mService.grantUriPermissionFromIntentLocked(mCallingUid, mStartActivity.packageName,
                mIntent, mStartActivity.getUriPermissionsLocked(), mStartActivity.userId);
        mService.grantEphemeralAccessLocked(mStartActivity.userId, mIntent,
                mStartActivity.appInfo.uid, UserHandle.getAppId(mCallingUid));
        if (mSourceRecord != null) {
            mStartActivity.getTask().setTaskToReturnTo(mSourceRecord);
        }
        if (newTask) {
            EventLog.writeEvent(
                    EventLogTags.AM_CREATE_TASK, mStartActivity.userId,
                    mStartActivity.getTask().taskId);
        }
        ActivityStack.logStartActivity(
                EventLogTags.AM_CREATE_ACTIVITY, mStartActivity, mStartActivity.getTask());
        mTargetStack.mLastPausedActivity = null;

        sendPowerHintForLaunchStartIfNeeded(false /* forceSend */, mStartActivity);

        mTargetStack.startActivityLocked(mStartActivity, topFocused, newTask, mKeepCurTransition,
                mOptions);
        if (mDoResume) {
            final ActivityRecord topTaskActivity =
                    mStartActivity.getTask().topRunningActivityLocked();
            if (!mTargetStack.isFocusable()
                    || (topTaskActivity != null && topTaskActivity.mTaskOverlay
                    && mStartActivity != topTaskActivity)) {
                
                mTargetStack.ensureActivitiesVisibleLocked(null, 0, !PRESERVE_WINDOWS);
               
                mWindowManager.executeAppTransition();
            } else {
                
                if (mTargetStack.isFocusable() && !mSupervisor.isFocusedStack(mTargetStack)) {
                    mTargetStack.moveToFront("startActivityUnchecked");
                }
                mSupervisor.resumeFocusedStackTopActivityLocked(mTargetStack, mStartActivity,
                        mOptions);
            }
        } else {
            mTargetStack.addRecentActivityLocked(mStartActivity);
        }
        mSupervisor.updateUserStackLocked(mStartActivity.userId, mTargetStack);

        mSupervisor.handleNonResizableTaskIfNeeded(mStartActivity.getTask(), preferredLaunchStackId,
                preferredLaunchDisplayId, mTargetStack.mStackId);

        return START_SUCCESS;
    }

> ActivityStackSupervisor.resumeFocusedStackTopActivityLocked()

	 boolean resumeFocusedStackTopActivityLocked(
            ActivityStack targetStack, 
			ActivityRecord target, 
			ActivityOptions targetOptions) {

        if (!readyToResume()) {
            return false;
        }

        if (targetStack != null && isFocusedStack(targetStack)) {
            return targetStack.resumeTopActivityUncheckedLocked(target, targetOptions);
        }

        final ActivityRecord r = mFocusedStack.topRunningActivityLocked();
        if (r == null || r.state != RESUMED) {
            mFocusedStack.resumeTopActivityUncheckedLocked(null, null);
        } else if (r.state == RESUMED) {
            mFocusedStack.executeAppTransition(targetOptions);
        }

        return false;
    }

> ActivityStack.resumeTopActivityUncheckedLocked()

     boolean resumeTopActivityUncheckedLocked(ActivityRecord prev, ActivityOptions options) {
        if (mStackSupervisor.inResumeTopActivity) {
            return false;
        }

        boolean result = false;
        try {
            mStackSupervisor.inResumeTopActivity = true;
            result = resumeTopActivityInnerLocked(prev, options);
        } finally {
            mStackSupervisor.inResumeTopActivity = false;
        }

        final ActivityRecord next = topRunningActivityLocked(true /* focusableOnly */);
        if (next == null || !next.canTurnScreenOn()) {
            checkReadyForSleep();
        }
        return result;
    }

> ActivityStack.resumeTopActivityInnerLocked()

      private boolean resumeTopActivityInnerLocked(
				ActivityRecord prev, 
				ActivityOptions options) {
        //... 这里的代码看不明白，有时间再深究
            mStackSupervisor.startSpecificActivityLocked(next, true, true);
		//...  
    }

> ActivityStackSupervisor.startSpecificActivityLocked()

    void startSpecificActivityLocked(ActivityRecord r,
            boolean andResume, boolean checkConfig) {
        //这个Activity的应用程序是否已经运行？
        ProcessRecord app = mService.getProcessRecordLocked(r.processName,
                r.info.applicationInfo.uid, true);

        r.getStack().setLaunchTime(r);

        if (app != null && app.thread != null) {
            try {
                if ((r.info.flags&ActivityInfo.FLAG_MULTIPROCESS) == 0
                        || !"android".equals(r.info.packageName)) {
					//如果它是一个标记为在多个进程中运行的平台组件，请不要添加它，因为这实际上是框架的一部分，因此在进程中跟踪单独的apk没有意义。
                    app.addPackage(r.info.packageName, r.info.applicationInfo.versionCode,
                            mService.mProcessStats);
                }
				//
                realStartActivityLocked(r, app, andResume, checkConfig);
                return;
            } catch (RemoteException e) {
                Slog.w(TAG, "Exception when starting activity "
                        + r.intent.getComponent().flattenToShortString(), e);
            } 
        }

        mService.startProcessLocked(r.processName, r.info.applicationInfo, true, 0,
                "activity", r.intent.getComponent(), false, false, true);
    }

> ActivityManagerService.startProcessLocked()

    final ProcessRecord startProcessLocked(String processName,
            ApplicationInfo info, boolean knownToBeDead, int intentFlags,
            String hostingType, ComponentName hostingName, boolean allowWhileBooting,
            boolean isolated, boolean keepIfLarge) {
        return startProcessLocked(processName, info, knownToBeDead, intentFlags, hostingType,
                hostingName, allowWhileBooting, isolated, 0 /* isolatedUid */, keepIfLarge,
                null /* ABI override */, null /* entryPoint */, null /* entryPointArgs */,
                null /* crashHandler */);
    }

	final ProcessRecord startProcessLocked(String processName, ApplicationInfo info,
            boolean knownToBeDead, int intentFlags, String hostingType, ComponentName hostingName,
            boolean allowWhileBooting, boolean isolated, int isolatedUid, boolean keepIfLarge,
            String abiOverride, String entryPoint, String[] entryPointArgs, Runnable crashHandler) {
         //...
        startProcessLocked(
                app, hostingType, hostingNameStr, abiOverride, entryPoint, entryPointArgs);
        
       //...
    }

     private final void startProcessLocked(ProcessRecord app, String hostingType,
            String hostingNameStr, String abiOverride, String entryPoint, String[] entryPointArgs) {

            
            if (entryPoint == null) entryPoint = "android.app.ActivityThread";
            //...
            if (hostingType.equals("webview_service")) {
	            //...
            } else {
                startResult = Process.start(entryPoint,
                        app.processName, uid, uid, gids, debugFlags, mountExternal,
                        app.info.targetSdkVersion, seInfo, requiredAbi, instructionSet,
                        app.info.dataDir, invokeWith, entryPointArgs);
            }
           //...
    }

> Process.start()



//下面的废弃的代码
> ActivityThread.currentActivityThread().getInstrumentation().execStartActivityFromAppTask()

	/**
     * Special version!
     * @hide
     */
    public void execStartActivityFromAppTask(Context who, IBinder contextThread, IAppTask appTask,Intent intent, Bundle options) {
        
		IApplicationThread whoThread = (IApplicationThread) contextThread;
        
		if (mActivityMonitors != null) {
            synchronized (mSync) {
                final int N = mActivityMonitors.size();
                for (int i=0; i<N; i++) {
                    final ActivityMonitor am = mActivityMonitors.get(i);
                    ActivityResult result = null;
                    if (am.ignoreMatchingSpecificIntents()) {
                        result = am.onStartActivity(intent);
                    }
                    if (result != null) {
                        am.mHits++;
                        return;
                    } else if (am.match(who, null, intent)) {
                        am.mHits++;
                        if (am.isBlocking()) {
                            return;
                        }
                        break;
                    }
                }
            }
        }

        try {
            intent.migrateExtraStreamToClipData();
            intent.prepareToLeaveProcess(who);
            int result = appTask.startActivity(whoThread.asBinder(), who.getBasePackageName(),
                    intent, intent.resolveTypeIfNeeded(who.getContentResolver()), options);
            checkStartActivityResult(result, intent);
        } catch (RemoteException e) {
            throw new RuntimeException("Failure from system", e);
        }
        return;
    }

AppTask是ActivityManager的内部类

>  appTask.startActivity()

	public void startActivity(Context context, Intent intent, Bundle options) {
            //获取ActivityThread对象
			ActivityThread thread = ActivityThread.currentActivityThread();
			//调用ActivityThread中的Instrumentation.execStartActivityFromAppTask()方法
            thread.getInstrumentation().execStartActivityFromAppTask(context,
                    thread.getApplicationThread(), mAppTaskImpl, intent, options);
    }




### 七、已经晕了的可以直接看这里








[https://www.cnblogs.com/jingmengxintang/p/7889311.html](https://www.cnblogs.com/jingmengxintang/p/7889311.html)


[https://blog.csdn.net/qianxiangsen/article/details/82414516](https://blog.csdn.net/qianxiangsen/article/details/82414516)


 
https://www.jianshu.com/p/9ecea420eb52

https://blankj.com/2018/09/29/the-process-of-app-start/

http://www.cnblogs.com/bastard/archive/2012/04/07/2436262.html

https://blog.csdn.net/to_tg/article/details/77431986

https://www.jianshu.com/p/8f6c0a962c40 