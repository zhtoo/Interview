## 事件处理机制

参考API27 

### 1、两个类

View ---> ViewGroup

### 2、三个方法

1. dispatchTouchEvent
2. onInterceptTouchEvent
3. onTouchEvent

### 3、源码

#### View的源码

事件传递的方法，决定当前事件是否被处理

    /**
     * Pass the touch screen motion event down to the target view, or this
     * view if it is the target.
     * 将触摸事件传递到 目标View（要处理该事件的View）
     * 返回True交由自己处理，false交由其他View处理
     */
    public boolean dispatchTouchEvent(MotionEvent event) {
         
		// 如果事件应该首先被辅助功能的焦点处理。
        if (event.isTargetAccessibilityFocus()) {
            // We don't have focus or no virtual descendant has it, do not handle the event.
            if (!isAccessibilityFocusedViewOrHost()) {
                return false;//不处理事件
            }
            // We have focus and got the event, then use normal event dispatch.
			// 我们获取到焦点并得到事件，然后使用正常的事件调度。
            event.setTargetAccessibilityFocus(false);
        }

        boolean result = false;

		//校验输入事件，一般这里我们不需要关心
        if (mInputEventConsistencyVerifier != null) {
            mInputEventConsistencyVerifier.onTouchEvent(event, 0);
        }
		
		//获取事件类型
        final int actionMasked = event.getActionMasked();
        if (actionMasked == MotionEvent.ACTION_DOWN) {//如果是按下事件
            // Defensive cleanup for new gesture
            stopNestedScroll();//停止正在进行的嵌套滚动。
        }

		//onFilterTouchEventForSecurity(event)： 筛选触摸事件的应用安全策略。
		//当视图被遮挡，放弃这个触摸事件。	
        if (onFilterTouchEventForSecurity(event)) {
            if ((mViewFlags & ENABLED_MASK) == ENABLED && handleScrollBarDragging(event)) {
                result = true;
            }
            //noinspection SimplifiableIfStatement
            ListenerInfo li = mListenerInfo;
            if (li != null && li.mOnTouchListener != null
                    && (mViewFlags & ENABLED_MASK) == ENABLED
                    && li.mOnTouchListener.onTouch(this, event)) {
                result = true;
            }
			// *** 在这里判断当前View是否处理当前事件
            if (!result && onTouchEvent(event)) {
                result = true;
            }
        }

		
        if (!result && mInputEventConsistencyVerifier != null) {
            mInputEventConsistencyVerifier.onUnhandledEvent(event, 0);
        }

        // Clean up after nested scrolls if this is the end of a gesture;
        // also cancel it if we tried an ACTION_DOWN but we didn't want the rest
        // of the gesture.
		//当事件类型为ACTION_UP、ACTION_CANCEL、（ACTION_DOWN并且不处理事件）等情况下
        if (actionMasked == MotionEvent.ACTION_UP ||
                actionMasked == MotionEvent.ACTION_CANCEL ||
                (actionMasked == MotionEvent.ACTION_DOWN && !result)) {
            stopNestedScroll();//停止正在进行的嵌套滚动。
        }

        return result;
    }

PS：将View的dispatchTouchEvent代码精简如下：

     public boolean dispatchTouchEvent(MotionEvent event) {
        //...
        boolean result = false;
		//... 	
        if (onFilterTouchEventForSecurity(event)) {
            //...
			// *** 在这里判断当前View是否处理当前事件
            if (!result && onTouchEvent(event)) {
                result = true;
            }
        } 
		//...
        return result;
    }

小结：一般View是否能够处理事件取决于其onTouchEvent是否需要处理事件。（开启辅助模式和视图消失的时候不适用）
 
#### 事件具体处理的地方

     public boolean onTouchEvent(MotionEvent event) {
        //获取当前触摸的坐标点（x，y）
		final float x = event.getX();
        final float y = event.getY();
        final int viewFlags = mViewFlags;
		//或当前事件的类型：按下、抬起、移动等
        final int action = event.getAction();

		//用于判断控件是否能够点击， xml中clickable对应CLICKABLE、
		//viewFlagValues |= CLICKABLE、viewFlagMasks |= CLICKABLE
        final boolean clickable = ((viewFlags & CLICKABLE) == CLICKABLE
                || (viewFlags & LONG_CLICKABLE) == LONG_CLICKABLE)
                || (viewFlags & CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE;
		
		//判断事件是不是点击事件
        if ((viewFlags & ENABLED_MASK) == DISABLED) {
            if (action == MotionEvent.ACTION_UP && (mPrivateFlags & PFLAG_PRESSED) != 0) {
                setPressed(false);
            }
            mPrivateFlags3 &= ~PFLAG3_FINGER_DOWN;
            // A disabled view that is clickable still consumes the touch
            // events, it just doesn't respond to them.
            return clickable;
        }
		//---处理点击事件结束-------------------------

		//mTouchDelegate 事件委托类
		/**
		* 辅助类，用于处理控件希望具有比实际控件边界更大的触摸区域的情况。 
		* 触摸区域需要更改的控件称为委托视图。 该类应该由委托的父类使用。 
		* 要使用TouchDelegate，首先要创建一个实例，指定应该映射到委托的边界和委托视图本身。
		*/
		//如果控件希望处理比实际边界更大的触摸区域时调用。
        if (mTouchDelegate != null) {
            if (mTouchDelegate.onTouchEvent(event)) {
                return true;
            }
        }

		//如果视图可以点击或者视图可以在悬停或长按时显示提示
        if (clickable || (viewFlags & TOOLTIP) == TOOLTIP) {
            switch (action) {
				//处理手势抬起操作
                case MotionEvent.ACTION_UP:
                    mPrivateFlags3 &= ~PFLAG3_FINGER_DOWN;
                    if ((viewFlags & TOOLTIP) == TOOLTIP) {
                        handleTooltipUp();
                    }

                    if (!clickable) {
                        removeTapCallback();
                        removeLongPressCallback();
                        mInContextButtonPress = false;
                        mHasPerformedLongPress = false;
                        mIgnoreNextUpEvent = false;
                        break;
                    }
                    boolean prepressed = (mPrivateFlags & PFLAG_PREPRESSED) != 0;
                    if ((mPrivateFlags & PFLAG_PRESSED) != 0 || prepressed) {
                        // take focus if we don't have it already and we should in
                        // touch mode.
                        boolean focusTaken = false;
                        if (isFocusable() && isFocusableInTouchMode() && !isFocused()) {
                            focusTaken = requestFocus();
                        }

                        if (prepressed) {
                            // The button is being released before we actually
                            // showed it as pressed.  Make it show the pressed
                            // state now (before scheduling the click) to ensure
                            // the user sees it.
                            setPressed(true, x, y);
                        }

                        if (!mHasPerformedLongPress && !mIgnoreNextUpEvent) {
                            // This is a tap, so remove the longpress check
                            removeLongPressCallback();

                            // Only perform take click actions if we were in the pressed state
                            if (!focusTaken) {
                                // Use a Runnable and post this rather than calling
                                // performClick directly. This lets other visual state
                                // of the view update before click actions start.
                                if (mPerformClick == null) {
                                    mPerformClick = new PerformClick();
                                }
                                if (!post(mPerformClick)) {
                                    performClick();
                                }
                            }
                        }

                        if (mUnsetPressedState == null) {
                            mUnsetPressedState = new UnsetPressedState();
                        }

                        if (prepressed) {
                            postDelayed(mUnsetPressedState,
                                    ViewConfiguration.getPressedStateDuration());
                        } else if (!post(mUnsetPressedState)) {
                            // If the post failed, unpress right now
                            mUnsetPressedState.run();
                        }

                        removeTapCallback();
                    }
                    mIgnoreNextUpEvent = false;
                    break;
				//处理手势按下操作
                case MotionEvent.ACTION_DOWN:
                    if (event.getSource() == InputDevice.SOURCE_TOUCHSCREEN) {
                        mPrivateFlags3 |= PFLAG3_FINGER_DOWN;
                    }
                    mHasPerformedLongPress = false;

                    if (!clickable) {
                        checkForLongClick(0, x, y);
                        break;
                    }

                    if (performButtonActionOnTouchDown(event)) {
                        break;
                    }

                    // Walk up the hierarchy to determine if we're inside a scrolling container.
                    boolean isInScrollingContainer = isInScrollingContainer();

                    // For views inside a scrolling container, delay the pressed feedback for
                    // a short period in case this is a scroll.
                    if (isInScrollingContainer) {
                        mPrivateFlags |= PFLAG_PREPRESSED;
                        if (mPendingCheckForTap == null) {
                            mPendingCheckForTap = new CheckForTap();
                        }
                        mPendingCheckForTap.x = event.getX();
                        mPendingCheckForTap.y = event.getY();
                        postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout());
                    } else {
                        // Not inside a scrolling container, so show the feedback right away
                        setPressed(true, x, y);
                        checkForLongClick(0, x, y);
                    }
                    break;
				//处理手势取消操作
                case MotionEvent.ACTION_CANCEL:
                    if (clickable) {
                        setPressed(false);
                    }
                    removeTapCallback();
                    removeLongPressCallback();
                    mInContextButtonPress = false;
                    mHasPerformedLongPress = false;
                    mIgnoreNextUpEvent = false;
                    mPrivateFlags3 &= ~PFLAG3_FINGER_DOWN;
                    break;
				//处理手势移动操作
                case MotionEvent.ACTION_MOVE:
                    if (clickable) {
                        drawableHotspotChanged(x, y);
                    }

                    // Be lenient about moving outside of buttons
                    if (!pointInView(x, y, mTouchSlop)) {
                        // Outside button
                        // Remove any future long press/tap checks
                        removeTapCallback();
                        removeLongPressCallback();
                        if ((mPrivateFlags & PFLAG_PRESSED) != 0) {
                            setPressed(false);
                        }
                        mPrivateFlags3 &= ~PFLAG3_FINGER_DOWN;
                    }
                    break;
            }
			//如果手势不是按下、移动、抬起或取消，就返回true。但是未具体处理事件
            return true;
        }

        return false;
    }

#### ViewGroup的源码

#### dispatchTouchEvent

    @Override
    public boolean dispatchTouchEvent(MotionEvent ev) {

		//输入事件一致性验证。
		//mInputEventConsistencyVerifier存在于View中，是被隐藏的属性。
		//在此理解为安全性检验即可。
        if (mInputEventConsistencyVerifier != null) {
            mInputEventConsistencyVerifier.onTouchEvent(ev, 1);
        }

        // If the event targets the accessibility focused view and this is it, start
        // normal event dispatch. Maybe a descendant is what will handle the click.
		//如果事件以可访问性为中心的视图为目标，那么就开始正常的事件处理。 也许子控件需要处理点击事件。
        if (ev.isTargetAccessibilityFocus() && isAccessibilityFocusedViewOrHost()) {
            ev.setTargetAccessibilityFocus(false);
        }

        boolean handled = false;

        if (onFilterTouchEventForSecurity(ev)) {
            final int action = ev.getAction();
            final int actionMasked = action & MotionEvent.ACTION_MASK;

            // Handle an initial down.
			//处理最初的按下事件。手势按下预处理
            if (actionMasked == MotionEvent.ACTION_DOWN) {
                // Throw away all previous state when starting a new touch gesture.
                // The framework may have dropped the up or cancel event for the previous gesture
                // due to an app switch, ANR, or some other state change.
				//清除并重置之前的触摸状态和标记
                cancelAndClearTouchTargets(ev);
                resetTouchState();
            }

            // Check for interception.
			// 检测是否拦截事件
            final boolean intercepted;
			//是按下手势 或者 mFirstTouchTarget不为空。
			//mFirstTouchTarget这个变量感觉就是灵魂所在。
			//事件分发机制大家都清了，而这里的代码就是进行事件的分发。
			//多一嘴，这里采用的是责任链模式。
			//在View中不需要，因为单个的View的处理事件是不传递的
			（例子：（大前提）传家宝（触摸事件）是一代代传下去的，你（view）现在还没有孩子，
			//现在你父亲（父类）已经把传家宝给你了，
			//因为膝下无子，你现在就只能自己保留传家宝或者交给你父亲。）。
            if (actionMasked == MotionEvent.ACTION_DOWN
                    || mFirstTouchTarget != null) {
				//当前是否允许拦截事件。常用requestDisallowInterceptTouchEvent(true)， 就是用来改变着个值的。
                final boolean disallowIntercept = (mGroupFlags & FLAG_DISALLOW_INTERCEPT) != 0;
				//如果有子类请求不拦截事件，那么将不执行onInterceptTouchEvent(ev);
                if (!disallowIntercept) {
                    intercepted = onInterceptTouchEvent(ev);
                    ev.setAction(action); // restore action in case it was changed
                } else {
                    intercepted = false;
                }
            } else {
                // There are no touch targets and this action is not an initial down
                // so this view group continues to intercept touches.
				//没有触摸目标并且此操作不是初始向下，因此该视图组继续拦截触摸事件。
                intercepted = true;
            }

            // If intercepted, start normal event dispatch. Also if there is already
            // a view that is handling the gesture, do normal event dispatch.
            // 拦截之后的事件处理
			if (intercepted || mFirstTouchTarget != null) {
                ev.setTargetAccessibilityFocus(false);
            }

            // Check for cancelation.
			//检测是否取消
            final boolean canceled = resetCancelNextUpFlag(this)
                    || actionMasked == MotionEvent.ACTION_CANCEL;

            // Update list of touch targets for pointer down, if needed.
			// 如果需要，更新指针向下的触摸目标列表。
            final boolean split = (mGroupFlags & FLAG_SPLIT_MOTION_EVENTS) != 0;
            
			TouchTarget newTouchTarget = null;

            boolean alreadyDispatchedToNewTouchTarget = false;

			// 不取消且不拦截（传递触摸事件）
            if (!canceled && !intercepted) {

                // If the event is targeting accessiiblity focus we give it to the
                // view that has accessibility focus and if it does not handle it
                // we clear the flag and dispatch the event to all children as usual.
                // We are looking up the accessibility focused host to avoid keeping
                // state since these events are very rare.

                View childWithAccessibilityFocus = ev.isTargetAccessibilityFocus()
                        ? findChildWithAccessibilityFocus() : null;

                if (actionMasked == MotionEvent.ACTION_DOWN
                        || (split && actionMasked == MotionEvent.ACTION_POINTER_DOWN)
                        || actionMasked == MotionEvent.ACTION_HOVER_MOVE) {
                    final int actionIndex = ev.getActionIndex(); // always 0 for down
                    final int idBitsToAssign = split ? 1 << ev.getPointerId(actionIndex)
                            : TouchTarget.ALL_POINTER_IDS;

                    // Clean up earlier touch targets for this pointer id in case they
                    // have become out of sync.

                    removePointersFromTouchTargets(idBitsToAssign);

                    final int childrenCount = mChildrenCount;
					//当控件里面还有view
                    if (newTouchTarget == null && childrenCount != 0) {
                        final float x = ev.getX(actionIndex);
                        final float y = ev.getY(actionIndex);

                        // Find a child that can receive the event.
                        // Scan children from front to back.
						//找一个可以接收事件的子view。 从前到后扫描子view。
						//将所有能够处理事件的子view添加到集合中
                        final ArrayList<View> preorderedList = buildTouchDispatchChildList();

						//isChildrenDrawingOrderEnabled：ViewGroup是否按照
						//{getChildDrawingOrder（int，int）}定义的顺序绘制其子项。
                        final boolean customOrder = preorderedList == null
                                && isChildrenDrawingOrderEnabled();
						//ViewGroup里面的控件数组
                        final View[] children = mChildren;
						//这里的循环式倒叙
                        for (int i = childrenCount - 1; i >= 0; i--) {
							//获取子控件的索引（主要是验证当前的索引）  
                            final int childIndex = getAndVerifyPreorderedIndex(
                                    childrenCount, i, customOrder);
							//获取i对应的控件（主要是验证当前的索引对应的view） 
                            final View child = getAndVerifyPreorderedView(
                                    preorderedList, children, childIndex);

                            // If there is a view that has accessibility focus we want it
                            // to get the event first and if not handled we will perform a
                            // normal dispatch. We may do a double iteration but this is
                            // safer given the timeframe.
							//这里是对辅助功能的校验

                            if (childWithAccessibilityFocus != null) {
                                if (childWithAccessibilityFocus != child) {
                                    continue;//跳过以下代码，继续下一个循环操作
                                }
                                childWithAccessibilityFocus = null;
                                i = childrenCount - 1;
                            }

                            if (!canViewReceivePointerEvents(child)
                                    || !isTransformedTouchPointInView(x, y, child, null)) {
                                ev.setTargetAccessibilityFocus(false);
                                continue;//跳过以下代码，继续下一个循环操作
                            }
					
							//校验mFirstTouchTarget中是否有对应view的TouchTarget
                            newTouchTarget = getTouchTarget(child);

                            if (newTouchTarget != null) {
                                // Child is already receiving touch within its bounds.
                                // Give it the new pointer in addition to the ones it is handling.
								//不为空即说明事件已经传递过。
                                newTouchTarget.pointerIdBits |= idBitsToAssign;
                                break;//终止循环
                            }
							//重置 
                            resetCancelNextUpFlag(child);
							//***划重点：dispatchTransformedTouchEvent：将事件传递给自己子View的dispatchTouchEvent
                            if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) {
                                // Child wants to receive touch within its bounds.
                               	//子View希望在自己边界内接收到触摸事件

								//获取到触摸事件
								mLastTouchDownTime = ev.getDownTime();
								
                                if (preorderedList != null) {
                                    // childIndex points into presorted list, find original index
									
                                    for (int j = 0; j < childrenCount; j++) {
                                        if (children[childIndex] == mChildren[j]) {
                                            mLastTouchDownIndex = j;
                                            break;
                                        }
                                    }
                                } else {
                                    mLastTouchDownIndex = childIndex;
                                }
                                mLastTouchDownX = ev.getX();
                                mLastTouchDownY = ev.getY();
								//如果子View需要处理事件，就在责任链上加一个TouchTarget
                                newTouchTarget = addTouchTarget(child, idBitsToAssign);

                                alreadyDispatchedToNewTouchTarget = true;
                                break;//终止循环
                            }

                            // The accessibility focus didn't handle the event, so clear
                            // the flag and do a normal dispatch to all children.
                           
							ev.setTargetAccessibilityFocus(false);
                        }//对子View遍历结束

						// 清空子View的集合
                        if (preorderedList != null) preorderedList.clear();

                    }//有子View时的代码结束

                    if (newTouchTarget == null && mFirstTouchTarget != null) {
                        // Did not find a child to receive the event.
                        // Assign the pointer to the least recently added target.
                        newTouchTarget = mFirstTouchTarget;
						
						//找到mFirstTouchTarget中最末端的TouchTarget
                        while (newTouchTarget.next != null) {
                            newTouchTarget = newTouchTarget.next;
                        }
                        newTouchTarget.pointerIdBits |= idBitsToAssign;
                    }
                }//处理按下、移动事件结束
            }//这个代码块里面的代码是关于 不取消且不拦截是对事件的处理

            // Dispatch to touch targets.
			//处理触摸目标。
            if (mFirstTouchTarget == null) {
                // No touch targets so treat this as an ordinary view.
				//没有TouchTarget，所以将其视为普通视图。
				//dispatchTransformedTouchEvent该方法下面分析
                handled = dispatchTransformedTouchEvent(ev, canceled, null,
                        TouchTarget.ALL_POINTER_IDS);
            } else {
                // Dispatch to touch targets, excluding the new touch target if we already
                // dispatched to it.  Cancel touch targets if necessary.

                TouchTarget predecessor = null;
                TouchTarget target = mFirstTouchTarget;
				
                while (target != null) {
                    final TouchTarget next = target.next;
                    if (alreadyDispatchedToNewTouchTarget && target == newTouchTarget) {
                        handled = true;
                    } else {
                        final boolean cancelChild = resetCancelNextUpFlag(target.child)
                                || intercepted;

                        if (dispatchTransformedTouchEvent(ev, cancelChild,
                                target.child, target.pointerIdBits)) {
                            handled = true;
                        }
                        if (cancelChild) {
                            if (predecessor == null) {
                                mFirstTouchTarget = next;
                            } else {
                                predecessor.next = next;
                            }
                            target.recycle();
                            target = next;
                            continue;
                        }
                    }
                    predecessor = target;
                    target = next;
                }
            }

            // Update list of touch targets for pointer up or cancel, if needed.
            if (canceled
                    || actionMasked == MotionEvent.ACTION_UP
                    || actionMasked == MotionEvent.ACTION_HOVER_MOVE) {
               	//重置触摸状态
				resetTouchState();
            } else if (split && actionMasked == MotionEvent.ACTION_POINTER_UP) {
                final int actionIndex = ev.getActionIndex();
                final int idBitsToRemove = 1 << ev.getPointerId(actionIndex);
                removePointersFromTouchTargets(idBitsToRemove);
            }
        }

        if (!handled && mInputEventConsistencyVerifier != null) {
            mInputEventConsistencyVerifier.onUnhandledEvent(ev, 1);
        }
        return handled;
    }

相关属性和方法说明：

mInputEventConsistencyVerifier 来自于View，被隐藏的成员变量。用来
	/**
     * Consistency verifier for debugging purposes.
     * 验证目标调试的一致性
     * @hide
     */
    protected final InputEventConsistencyVerifier mInputEventConsistencyVerifier =
            InputEventConsistencyVerifier.isInstrumentationEnabled() ?
                    new InputEventConsistencyVerifier(this, 0) : null;

onFilterTouchEventForSecurity(ev)：这里是对触摸事件做安全校验

	 /**
	  * Filter the touch event to apply security policies.
	  * 使用应用安全策略过滤触摸事件。
	  * @see #getFilterTouchesWhenObscured（具体参见getFilterTouchesWhenObscured方法）
	  */
	 public boolean onFilterTouchEventForSecurity(MotionEvent event) {
	     if ((mViewFlags & FILTER_TOUCHES_WHEN_OBSCURED) != 0
	             && (event.getFlags() & MotionEvent.FLAG_WINDOW_IS_OBSCURED) != 0) {
	         // Window is obscured, drop this touch.
			//当窗口处于模糊状态（不可见或即将消失），放弃这个事件
	         return false;
	     }
	     return true;
	 }

requestDisallowInterceptTouchEvent（true）：请求父类不拦截事件。

 	@Override
    public void requestDisallowInterceptTouchEvent(boolean disallowIntercept) {

        if (disallowIntercept == ((mGroupFlags & FLAG_DISALLOW_INTERCEPT) != 0)) {
            return;
        }

        if (disallowIntercept) {
            mGroupFlags |= FLAG_DISALLOW_INTERCEPT;
        } else {
            mGroupFlags &= ~FLAG_DISALLOW_INTERCEPT;
        }

        if (mParent != null) {
            mParent.requestDisallowInterceptTouchEvent(disallowIntercept);
        }
    }

dispatchTouchEvent的事件传递：dispatchTransformedTouchEvent
dispatchTransformedTouchEvent里面的逻辑无非就是判断事件是交给子View处理还是交由父类（View类的dispatchTouchEvent）处理。

	 private boolean dispatchTransformedTouchEvent(MotionEvent event, boolean cancel,
            View child, int desiredPointerIdBits) {
        final boolean handled;

        // Canceling motions is a special case.  We don't need to perform any transformations
        // or filtering.  The important part is the action, not the contents.

        final int oldAction = event.getAction();
        if (cancel || oldAction == MotionEvent.ACTION_CANCEL) {
            event.setAction(MotionEvent.ACTION_CANCEL);
            if (child == null) {
                handled = super.dispatchTouchEvent(event);
            } else {
                handled = child.dispatchTouchEvent(event);
            }
            event.setAction(oldAction);
            return handled;
        }

        // Calculate the number of pointers to deliver.

        final int oldPointerIdBits = event.getPointerIdBits();
        final int newPointerIdBits = oldPointerIdBits & desiredPointerIdBits;

        // If for some reason we ended up in an inconsistent state where it looks like we
        // might produce a motion event with no pointers in it, then drop the event.

        if (newPointerIdBits == 0) {
            return false;
        }

        // If the number of pointers is the same and we don't need to perform any fancy
        // irreversible transformations, then we can reuse the motion event for this
        // dispatch as long as we are careful to revert any changes we make.
        // Otherwise we need to make a copy.

        final MotionEvent transformedEvent;
        if (newPointerIdBits == oldPointerIdBits) {
            if (child == null || child.hasIdentityMatrix()) {
                if (child == null) {
                    handled = super.dispatchTouchEvent(event);
                } else {
                    final float offsetX = mScrollX - child.mLeft;
                    final float offsetY = mScrollY - child.mTop;
                    event.offsetLocation(offsetX, offsetY);

                    handled = child.dispatchTouchEvent(event);

                    event.offsetLocation(-offsetX, -offsetY);
                }
                return handled;
            }
            transformedEvent = MotionEvent.obtain(event);
        } else {
            transformedEvent = event.split(newPointerIdBits);
        }

        // Perform any necessary transformations and dispatch.

        if (child == null) {
            handled = super.dispatchTouchEvent(transformedEvent);
        } else {
            final float offsetX = mScrollX - child.mLeft;
            final float offsetY = mScrollY - child.mTop;
            transformedEvent.offsetLocation(offsetX, offsetY);
            if (! child.hasIdentityMatrix()) {
                transformedEvent.transform(child.getInverseMatrix());
            }

            handled = child.dispatchTouchEvent(transformedEvent);
        }

        // Done.
        transformedEvent.recycle();
        return handled;
    }

**小结： ViewGroup是否处理事件由：是否不允许拦截和onInterceptTouchEvent（）决定**

#### 事件拦截

    public boolean onInterceptTouchEvent(MotionEvent ev) {
        if (ev.isFromSource(InputDevice.SOURCE_MOUSE)
                && ev.getAction() == MotionEvent.ACTION_DOWN
                && ev.isButtonPressed(MotionEvent.BUTTON_PRIMARY)
                && isOnScrollbarThumb(ev.getX(), ev.getY())) {
            return true;
        }
        return false;
    }

**小结： onInterceptTouchEvent（）只会在 ACTION_DOWN 的时候 返回true 。**

### 4、分析

1、在view中实现了dispatchTouchEvent和onTouchEvent方法；ViewGroup实现了dispatchTouchEvent和onInterceptTouchEvent方法，onTouchEvent为具体实现，因为集成View，可以看作其onTouchEvent的实现就是View中的onTouchEvent。
2、dispatchTouchEvent的注释说明该方法只负责传递事件，而不具体处理事件。
3、onInterceptTouchEvent  不能消费事件  只能决定事件是否被当前View消费
4、onInterceptTouchEvent 方法对触屏事件的拦截处理需要和onTouchEvent方法配合使用。
5、down事件首先传递到onInterceptTouchEvent方法中
6、onInterceptTouchEvent返回false表示将down事件交由子View来处理；
  	若某一层子View的onTouchEvent返回了true，后续的move、up等事件都将先传递到ViewGroup的onInterceptTouchEvent的方法，并继续层层传递下去，交由子View处理；
 	若子View的onTouchEvent都返回了false，则down事件将交由该ViewGroup的onTouchEvent来处理；
 	如果ViewGroup的onTouchEvent返回false，down传递给父ViewGroup，后续事件不再传递给该ViewGroup；
  	如果ViewGroup的onTouchEvent返回true，后续事件不再经过该ViewGroup的onInterceptTouchEvent方法，直接传递给onTouchEvent方法处理
7、onInterceptTouchEvent返回ture，down事件将转交该ViewGroup的onTouchEvent来处理；
 	若onTouchEvent返回true，后续事件将不再经过该ViewGroup的onInterceptTouchEvent方法，直接交由该ViewGroup的onTouchEvent方法处理；
  	若onTouchEvent方法返回false，后续事件都将交由父ViewGroup处理，不再经过该ViewGroup的onInterceptTouchEvent方法和onTouchEvent方法
 